# Keep things tidy

```{epigraph}
Does it spark joy?

--Marie Kondo
```

Keeping things consistent and tidy will free your working memory from having to remember extraneous names and locations.

## Use the style guide

Generally, Python uses:

* Snake case for variables and module: `variable_name`, `my_module.py`
* Camel case for class name: `MyClass`
* Camel case with spaces for jupyter notebook: `Analyze Brain Data.ipynb`

You might know that Python generally uses 4 spaces for indentation, and that files are expected to be at most 80 columns long. These and many other elements of style are written in [PEP 8](https://www.python.org/dev/peps/pep-0008/). Code that adheres to style tends to be easier to read.

```{margin}
Big software companies like Google [have their own coding style guide](https://google.github.io/styleguide/pyguide.html). Even Guido von Rossum, inventor of Python, had to follow Google's style guide when he was working at Google.
```

Reading style guides is nobody's idea of a good time, but thankfully tools exist to help you maintain good coding style. If you prefer to eventually learn the rules, you can install `flake8` or `pylint`. Both tools are *linters* - detectors of bad style - which allow you to find and correct common deviations from the style guide. The ideal place to use the linter is inside of an IDE, [for example VSCode](https://code.visualstudio.com/docs/python/linting). It's also possible to use linters from the command line. 

A more radical way to impose style is to use a *code formatter*. A linter suggests fixes which you implement yourself; a formatter fixes issues automatically whenever you save a file. `black` [imposes consistent Python style](https://github.com/psf/black), and has plugins for all the popular IDEs.

### Docstrings

Python uses multi-line strings - docstrings - to document individual functions. Docstrings can be read by humans directly. They can be also be read by machines to create HTML documentation like the kind you see on [readthedocs](https://docs.readthedocs.io/en/stable/). There are three prevalent styles of docstrings:

```{margin}
[Sphinx](https://www.sphinx-doc.org/en/master/) is the standard way to generate HTML documentation in Python. Sphinx is very powerful - this book is generated by jupyterbook, which uses sphinx to do its job!
```

* [reST (reStructuredText)](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html)
* [Google style](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html)
* [Numpy style](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html)

reST is more prevalent because it's the default in Sphinx, but I think the Google style is easier to read for humans and I prefer it. Here's how you would document a function which counts the number of occurences of a line:

```{margin}
Sphinx can auto-generate docs from Google and Numpy-style docstrings [with a plugin](https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html).
```

````{tabbed} Google-style
```
def count_line(f, line):
    """
    Counts the number of times a line occurs. Case-sensitive.

    Arguments:
        f (file): the file to scan
        line (str): the line to count

    Returns:
        int: the number of times the line occurs.
    """
    num_instances = 0
    for l in f:
        if l.strip() == line:
            num_instances += 1

    return num_instances
```
````

````{tabbed} Numpy-style
```
def count_line(f, line):
    """
    Counts the number of times a line occurs. Case-sensitive.

    Parameters
    ----------
    f: file
        the file to scan
    line: str
        the line to count

    Returns
    -------
    int
        the number of times the line occurs.
    """
    num_instances = 0
    for l in f:
        if l.strip() == word:
            num_instances += 1

    return num_instances
```
````

````{tabbed} reST
```
def count_word(f, line):
    """
    Counts the number of times a line occurs. Case-sensitive.

    :param f: the file to scan
    :type f: file
    :param line: the line to count
    :type line: str
    :returns: the number of times the line occurs.
    :rtype: int
    """
    num_instances = 0
    for l in f:
        if l.strip() == line:
            num_instances += 1

    return num_instances
```
````

See which one you prefer and stick to it.

## Delete dead code

Code that gets developed over time can accumulate lots of dead ends and odds and ends. After a while, the majority of the code in your project might be dead: code that never gets called. You know who hates dead code? You, in three months. Navigating a project that contains stale or incorrect code can waste a huge amount of time. Whenever you're about to put aside a project for a long time - for instance, after submitting a manuscript - *clean up dead code*. Delete dead code from the main branch. With git and github, you have access to a time machine, so you can always revert if you mess up. 

If you're not used to this workflow, you might be scared of messing something up. You can download an archive of the repo before the cleanup to reassure yourself. If you've been diligent about committing and pushing code to Github, however, deleting dead code is a safe process. [`vulture` can help you find dead code in your codebase](https://github.com/jendrikseipp/vulture). Unit tests can help you verify that your codebase will still run after you eliminate dead code -- we will cover this is a later lesson.

## Keep jupyter notebooks tidy

```{epigraph}
If you use notebooks to develop software, you are probably using the wrong tool. 

-- [Yihui Xie](https://yihui.org/en/2018/09/notebook-war/)
```

Jupyter notebooks present a special challenge to keep things tidy because of their inherently nonlinear nature. It's commonplace for long-running notebooks to accumulate cruft at the end of the notebooks: dead cells, out-of-date analyses, inaccurate commentary. 

Before you commit a notebook to git, get into the habit of *restarting the kernel and running all*. Often, you will find that the notebook will not run top to bottom. This is easy to fix when you remember the context of code; in several months, however, it will be next to impossible to understand.

You might have a long-running pipeline in a cell, and executing the whole notebook could take several hours. If that's the case, consider moving the relevant code outside the notebook and into a separate script. While it's ok to write plotting code in a notebook, writing big functions and pipelines will make it harder to test your code and make sure it runs top to bottom. It can be difficult to co-develop a notebook and a module side-by-side, because whenever you change the module you will need to reload the library, often by restarting the kernel. Using these two magics will ensure that the module is automatically reloaded in jupyter whenever the module code is changed.

```python
%load_ext autoreload
%autoreload 2
```

Refactoring and cleaning up a notebook can be a pain in the jupyter environment: think about how annoying it can be to move a cell across several screens. [`jupytext` can seamlessly translate between a regular jupyter notebook and a markdown-based textual representation](https://github.com/mwouts/jupytext). In my opinion, refactoring and moving cells around is far easier in the text representation.

Now, it will feel uncomfortable to move away from jupyter notebooks for some workflows. You might be used to writing small snippets of code and then interact with it immediately to see whether it works - moving the code to a module means you can't use in this very immediate fashion. We'll fix this discomfort later as we learn about testing.

## Discussion

```{epigraph}
There should be one -- and preferably only one -- obvious way to do it.

-- [The Zen of Python](https://zen-of-python.info/there-should-be-one-and-preferably-only-one-obvious-way-to-do-it.html#13)
```

It's easy to mock style guides as pedantic nitpicking. After all, style, like spelling, is ultimately arbitrary. However, adhering to a standard style can help you preserve your working memory. Don't spend precious mental energy making lots of micro-decisions about variable names and how many spaces to put after a parenthesis: use the style guide. If there's an obvious way of doing things, do it that way. 

The short term advantage of using consistent structure compoungs over time. Once you've put aside a project for long enough, you will need to reacquaint yourself with it anew, and cruft and dead ends will no longer make sense. Maintaining good code hygiene will make your future self happy.